# API Contract: Playbooks

## Overview

This document describes the contract for the `GET /v1/playbooks` endpoint and explains the normalization layer implemented in `admin-proxy`.

## Endpoint

```
GET /v1/playbooks
```

## Response Contract (Frontend)

The frontend expects and receives a **normalized response**:

```json
{
  "items": [
    {
      "key": "system.test_ping",
      "version": "1.0",
      "title": "System Ping",
      "description": "Test connectivity with the runner",
      "visibility": "public",
      "actions": ["run"],
      "schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "category": "BASE",
      "riskLevel": "LOW"
    }
  ],
  "proxy_target": "https://api.ikomadigit.com/v1/playbooks",
  "proxy_status": 200,
  "proxy_duration": 126
}
```

### Required Fields (Contract)

| Field | Type | Description |
|-------|------|-------------|
| `key` | `string` | Unique playbook identifier (e.g., `system.test_ping`) |
| `version` | `string` | Playbook version (e.g., `"1.0"`) |
| `title` | `string` | Human-readable title |
| `description` | `string` | Short description |
| `visibility` | `"public" \| "internal"` | Access level |
| `actions` | `string[]` | Available actions (e.g., `["run"]`) |
| `schema` | `object` | JSON Schema for parameters |

### Optional Fields (Pass-through)

| Field | Type | Description |
|-------|------|-------------|
| `category` | `string` | Grouping category from API |
| `riskLevel` | `string` | Risk level from API |

---

## Raw API Response (Backend Issue)

### Problem: Indexed Object Format

The IKOMA Engine API (`api.ikomadigit.com`) returns an **indexed object** instead of an array:

```json
{
  "0": {
    "id": "005a72fa-f684-4d0e-9885-f6c685879925",
    "key": "smoke-test-1768669315",
    "name": "Smoke Test Playbook",
    "isPublished": "false",
    "schemaVersion": "1.0",
    "spec": { "steps": [] },
    "category": "BASE",
    "riskLevel": "LOW"
  },
  "1": {
    "id": "35edaac7-7b9f-4ca1-8a53-76c4de104a4b",
    "key": "system.test_ping",
    "name": "System Ping",
    "isPublished": "true",
    "schemaVersion": "1"
  }
}
```

### Root Cause

This format is generated by the **IKOMA Engine API** (Node.js backend) when serializing query results. The likely causes:

1. **ORM/Query Builder**: Sequelize or similar ORMs sometimes return result sets as indexed objects when using certain query methods
2. **JSON Serialization**: Manual iteration converting arrays to objects with numeric keys
3. **Legacy Compatibility**: Older API versions may have used this format for pagination cursors

### Where It Happens

```
┌─────────────────┐    {0:…,1:…}    ┌─────────────────┐    { items: [...] }    ┌──────────────┐
│  IKOMA Engine   │ ──────────────> │   admin-proxy   │ ───────────────────> │   Frontend   │
│  (Node.js API)  │                 │  (Edge Function) │                      │   (React)    │
└─────────────────┘                 └─────────────────┘                      └──────────────┘
        ↑                                    ↑
   Generates indexed                  Normalizes to
   object format                      { items: [...] }
```

---

## Normalization Layer (admin-proxy)

The `admin-proxy` Edge Function handles the conversion in `supabase/functions/admin-proxy/index.ts`:

```typescript
// For GET /playbooks, normalize to { items: [...] } with contractual fields
if (path === '/playbooks' && httpMethod === 'GET') {
  // Handle multiple API response formats
  let rawPlaybooks: Record<string, unknown>[] = [];
  
  if (Array.isArray(responseData?.items)) {
    rawPlaybooks = responseData.items;
  } else if (Array.isArray(responseData)) {
    rawPlaybooks = responseData;
  } else if (typeof responseData === 'object' && responseData !== null) {
    // Indexed object format { "0": {...}, "1": {...} }
    rawPlaybooks = Object.entries(responseData)
      .filter(([key]) => !key.startsWith('proxy_') && !isNaN(Number(key)))
      .map(([, value]) => value as Record<string, unknown>);
  }

  // Normalize each playbook to contractual schema
  const items = rawPlaybooks.map((raw) => ({
    key: raw.key,
    version: raw.version || raw.schemaVersion || '1.0',
    title: raw.title || raw.name || raw.key,
    description: raw.description || raw.name || raw.key,
    visibility: determineVisibility(raw),
    actions: Array.isArray(raw.actions) ? raw.actions : ['run'],
    schema: raw.schema || { type: 'object', properties: {}, required: [] },
    category: raw.category,
    riskLevel: raw.riskLevel,
  }));

  return Response.json({ items, ...proxyMetadata });
}
```

### Field Mapping

| API Field | Frontend Field | Transformation |
|-----------|----------------|----------------|
| `name` | `title` | Direct copy or fallback to `key` |
| `name` | `description` | Direct copy or fallback to `key` |
| `isPublished` | `visibility` | `"true"` → `"public"`, `"false"` → `"internal"` |
| `schemaVersion` | `version` | Direct copy |
| `spec` | `schema` | Direct copy or default `{}` |

---

## Testing

Contract tests are available at:

```bash
deno test --allow-net --allow-env supabase/functions/admin-proxy/index.test.ts
```

Tests verify:
1. Response has `{ items: [...] }` structure
2. Each item has required contractual fields
3. No indexed object format `{0:…,1:…}` in response
4. Schema has valid structure

---

## Recommended API Fix

To eliminate the need for normalization, the IKOMA Engine should be updated to:

1. Return standard array format: `{ "items": [...] }` or `[...]`
2. Use consistent field names: `title` instead of `name`
3. Use boolean `isPublished: true/false` instead of string `"true"/"false"`
4. Include `visibility` field directly

Until the API is fixed, the `admin-proxy` normalization layer ensures frontend stability.
